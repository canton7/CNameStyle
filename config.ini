[Static variables must begin with s_]
kind = variable
visibility = file
rule = s_${case:camel}

[Static functions must be PascalCase]
kind = function
visibility = file
rule = ${case:pascal}

[Non-static functions must be PascalCase]
kind = function
visibility = global
rule = ${filename:stem}_${case:pascal}

[Pointer parameters and local variables of char type must be camelCase starting with an optional 'p']
kind = parameter:pointer, variable:pointer, struct_member:pointer
visibility = local
type = (const )?char \*(const)?
rule = (p{${pointer-level}}${case:pascal})|${case:camel}

[Pointer parameters and local variables must be camelCase starting with 'p']
kind = parameter:pointer, variable:pointer, struct_member:pointer
visibility = local
rule = p{${pointer-level}}${case:pascal}

[Parameters and local variables must be camelCase]
kind = parameter, variable, struct_member
visibility = local
rule = ${case:camel}

[Enum members must start with the enum name]
kind = enum_member
parent_match = (?P<name>.*)_t(ag)?
rule = ${parent}_${case:pascal}

[Global variables must be PascalCase]
kind = variable
visibility = global
rule = ${filename:stem}_${case:pascal}

[Struct and enum tags must be PascalCase ending in _tag]
kind = struct_tag, enum_tag
visibility = global
rule = ${filename:stem}(_${case:pascal})?_tag

[Local struct and enum tags must be PascalCase ending in _tag]
kind = struct_tag, enum_tag
visibility = file
rule = ${case:pascal}?_tag

[Struct and enum typedefs must be PascalCase ending in _t]
kind = struct_typedef, enum_typedef, function_pointer_typedef
visibility = global
rule = ${filename:stem}(_${case:pascal})?_t

[Local struct and enum typedefs must be PascalCase ending in _t]
kind = struct_typedef, enum_typedef, function_pointer_typedef
visibility = file
rule = ${case:pascal}_t
