[Static variables must begin with s_]
kind = variable
visibility = file
prefix = s_

[Static functions must be PascalCase]
kind = function
visibility = file
rule = ${case:pascal}

[Global functions must be PascalCase and start with the filename]
kind = function
visibility = global
rule = ${filename:stem}_${case:pascal}

[Pointer parameters and local variables of char type must be camelCase starting with an optional 'p']
kind = parameter, variable, struct_member
visibility = local
pointer = true
type = (const )?char \*(const)?
rule = (p{${pointer-level}}${case:pascal})|(${case:camel})

[Pointer parameters and local variables must be camelCase starting with 'p']
kind = parameter, variable, struct_member
visibility = local, file
pointer = true
rule = p{${pointer-level}}${case:pascal}

[Global variables must be begin with the file name]
kind = variable
visibility = global
prefix = ${filename:stem}_
suffix = Foo

[Global pointer variables must begin with 'p']
kind = variable
visibility = global
pointer = true
prefix = p{${pointer-level}}

[Global variables must be PascalCase]
kind = variable
visibility = global
rule = ${case:pascal}

[Parameters and local variables must be camelCase]
kind = parameter, variable, struct_member
visibility = local, file
rule = ${case:camel}

[Enum members must start with the enum name]
kind = enum_member
parent_match = (?P<name>.*)_t(ag)?
rule = ${parent}_${case:pascal}

[Struct and enum tags must be PascalCase ending in _tag]
kind = struct_tag, enum_tag
visibility = global
rule = ${filename:stem}(_${case:pascal})?_tag

[Local struct and enum tags must be PascalCase ending in _tag]
kind = struct_tag, enum_tag
visibility = file
rule = ${case:pascal}?_tag

[Struct and enum typedefs must be PascalCase ending in _t]
kind = struct_typedef, enum_typedef, function_typedef
visibility = global
rule = ${filename:stem}(_${case:pascal})?_t

[Local struct and enum typedefs must be PascalCase ending in _t]
kind = struct_typedef, enum_typedef, function_typedef
visibility = file
rule = ${case:pascal}_t
